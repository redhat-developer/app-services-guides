////
START GENERATED ATTRIBUTES
WARNING: This content is generated by running npm --prefix .build run generate:attributes
////

//All OpenShift Application Services
:org-name: Application Services
:product-long-rhoas: OpenShift Application Services
:community:
:imagesdir: ./images
:property-file-name: app-services.properties
:samples-git-repo: https://github.com/redhat-developer/app-services-guides
:base-url: https://github.com/redhat-developer/app-services-guides/tree/main/docs/
:sso-token-url: https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

//OpenShift Application Services CLI
:base-url-cli: https://github.com/redhat-developer/app-services-cli/tree/main/docs/
:command-ref-url-cli: commands
:installation-guide-url-cli: rhoas/rhoas-cli-installation/README.adoc
:service-contexts-url-cli: rhoas/rhoas-service-contexts/README.adoc

//OpenShift Streams for Apache Kafka
:product-long-kafka: OpenShift Streams for Apache Kafka
:product-kafka: Streams for Apache Kafka
:product-version-kafka: 1
:service-url-kafka: https://console.redhat.com/application-services/streams/
:getting-started-url-kafka: kafka/getting-started-kafka/README.adoc
:kafka-bin-scripts-url-kafka: kafka/kafka-bin-scripts-kafka/README.adoc
:kafkacat-url-kafka: kafka/kcat-kafka/README.adoc
:quarkus-url-kafka: kafka/quarkus-kafka/README.adoc
:nodejs-url-kafka: kafka/nodejs-kafka/README.adoc
:getting-started-rhoas-cli-url-kafka: kafka/rhoas-cli-getting-started-kafka/README.adoc
:topic-config-url-kafka: kafka/topic-configuration-kafka/README.adoc
:consumer-config-url-kafka: kafka/consumer-configuration-kafka/README.adoc
:access-mgmt-url-kafka: kafka/access-mgmt-kafka/README.adoc
:metrics-monitoring-url-kafka: kafka/metrics-monitoring-kafka/README.adoc
:service-binding-url-kafka: kafka/service-binding-kafka/README.adoc
:message-browsing-url-kafka: kafka/message-browsing-kafka/README.adoc

//OpenShift Service Registry
:product-long-registry: OpenShift Service Registry
:product-registry: Service Registry
:registry: Service Registry
:product-version-registry: 1
:service-url-registry: https://console.redhat.com/application-services/service-registry/
:getting-started-url-registry: registry/getting-started-registry/README.adoc
:quarkus-url-registry: registry/quarkus-registry/README.adoc
:getting-started-rhoas-cli-url-registry: registry/rhoas-cli-getting-started-registry/README.adoc
:access-mgmt-url-registry: registry/access-mgmt-registry/README.adoc
:content-rules-registry: https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/9b0fdf14-f0d6-4d7f-8637-3ac9e2069817[Supported Service Registry content and rules]
:service-binding-url-registry: registry/service-binding-registry/README.adoc

//OpenShift Connectors
:product-long-connectors: OpenShift Connectors
:product-connectors: Connectors
:product-version-connectors: 1
:service-url-connectors: https://console.redhat.com/application-services/connectors
:getting-started-url-connectors: connectors/getting-started-connectors/README.adoc

//OpenShift API Designer
:product-long-api-designer: OpenShift API Designer
:product-api-designer: API Designer
:product-version-api-designer: 1
:service-url-api-designer: https://console.redhat.com/application-services/api-designer/
:getting-started-url-api-designer: api-designer/getting-started-api-designer/README.adoc

//OpenShift API Management
:product-long-api-management: OpenShift API Management
:product-api-management: API Management
:product-version-api-management: 1
:service-url-api-management: https://console.redhat.com/application-services/api-management/

////
END GENERATED ATTRIBUTES
////

[id="chap-using-nodejs"]
= Using Node.js applications with Kafka instances in {product-long-kafka}
ifdef::context[:parent-context: {context}]
:context: using-nodejs

// Purpose statement for the assembly
[role="_abstract"]
As a developer of applications and services, you can connect Node.js applications to Kafka instances in {product-long-kafka}. https://nodejs.org/en/about/[Node.js^] is a server-side JavaScript runtime that is designed to build scalable network applications. Node.js provides an I/O model that is based on events and non-blocking operations, which enables efficient applications.

In this quick start, you'll use the {product-kafka} web console to collect connection information for a Kafka instance. Then you'll manually configure a connection from an example Node.js application to the Kafka instance and start producing and consuming messages.

NOTE: When you've completed this quick start and understand the required connection configuration for a Kafka instance, you can use the {product-long-rhoas} command-line interface (CLI) to generate this type of configuration in a more automated way. To learn more, see {base-url}{service-contexts-url-cli}[Connecting client applications to {product-long-rhoas} using the rhoas CLI^].

.Prerequisites
ifndef::community[]
* You have a Red Hat account.
endif::[]
* You have a Kafka instance in {product-kafka} and the instance is in the *Ready* state. To learn how to create a Kafka instance, see {base-url}{getting-started-url-kafka}[Getting started with {product-long-kafka}].
* https://github.com/git-guides/[Git^] is installed.
* You have an IDE such as https://www.jetbrains.com/idea/download/[IntelliJ IDEA^], https://www.eclipse.org/downloads/[Eclipse^], or https://code.visualstudio.com/Download[VSCode^].
* https://nodejs.org/en/download/[Node.js 14^] is installed. The https://github.com/blizzard/node-rdkafka[node-rdkafka^] client can't run on later versions.

NOTE: The example Node.js application in this quick start uses the https://kafka.js.org/[KafkaJS^] client by default. If you want to use the https://github.com/blizzard/node-rdkafka[node-rdkafka^] client, you must install some development tools locally on your computer or use a container runtime such as Podman or Docker to run a specified container image and configure a development environment. To learn more, see the https://github.com/nodeshift-starters/reactive-example/tree/node-rdkafka#node-rdkafka-and-kafkajs[documentation] for the example Node.js application.


// Condition out QS-only content so that it doesn't appear in docs.
// All QS anchor IDs must be in this alternate anchor ID format `[#anchor-id]` because the ascii splitter relies on the other format `[id="anchor-id"]` to generate module files.
ifdef::qs[]
[#description]
====
Learn how to manually connect a Node.js application to a Kafka instance in {product-long-kafka} and then produce and consume messages.
====

[#introduction]
====
Welcome to the quick start for {product-long-kafka} with Node.js. In this quick start, you'll use the web console to collect connection information for a Kafka instance in {product-kafka}. Then you'll manually configure a connection from an example https://nodejs.org/en/about/[Node.js^] application to the Kafka instance and start producing and consuming messages.
====
endif::[]


[id="proc-importing-nodejs-sample-code_{context}"]
== Importing the Node.js sample code

[role="_abstract"]
For this quick start, you'll use sample code from the _Nodeshift Application Starters_ https://github.com/nodeshift-starters/reactive-example[reactive-example^] repository in GitHub. After you understand the concepts and tasks in this quick start, you can use your own Node.js applications with {product-kafka} in the same way.

.Procedure
. On the command line, clone the Nodeshift Application Starters https://github.com/nodeshift-starters/reactive-example[reactive-example^] repository from GitHub.
+
.Cloning the reactive-example repository
[source,subs="+attributes"]
----
$ git clone https://github.com/nodeshift-starters/reactive-example.git
----
. In your IDE, open the `reactive-example` directory of the repository that you cloned.

ifdef::qs[]
.Verification
* Is the Node.js example application accessible in your IDE?
endif::[]

[id="proc-configuring-nodejs_{context}"]
== Configuring the Node.js example application to connect to a Kafka instance

[role="_abstract"]
To enable your Node.js application to access a Kafka instance, you must configure a connection by specifying the following details:

* The bootstrap server endpoint for your Kafka instance
* The generated credentials for your {product-kafka} service account
* The Simple Authentication and Security Layer (SASL) mechanism that the client will use to authenticate with the Kafka instance

In this task, you'll create a new configuration file called `rhoas.env`. In this file, you'll set the required bootstrap server and client credentials as environment variables.

.Prerequisites
ifndef::qs[]
* You have the bootstrap server endpoint for your Kafka instance. To get the server endpoint, select your Kafka instance in the {product-kafka} web console, select the options menu (three vertical dots), and click *Connection*.
* You have the generated credentials for your service account. To regenerate the credentials, use the *Service Accounts* page in the {product-kafka} web console to find your service account and update the credentials.
* You've set the permissions for your service account to access the Kafka instance resources. To verify the current permissions, select your Kafka instance in the {product-kafka} web console and use the *Access* page to find your service account permission settings.
endif::[]

.Procedure

. In your IDE, create a new file. Save the file with the name `rhoas.env`, at the root level of the `reactive-example` directory for the cloned repository.

. In the `rhoas.env` file, add the lines shown in the example. These lines set the bootstrap server and client credentials as environment variables to be used by the Node.js application.
+
.Setting environment variables in the rhoas.env file
[source,subs="+quotes"]
----
KAFKA_HOST=__<bootstrap_server>__
RHOAS_SERVICE_ACCOUNT_CLIENT_ID=__<client_id>__
RHOAS_SERVICE_ACCOUNT_CLIENT_SECRET=__<client_secret>__
KAFKA_SASL_MECHANISM=plain
----
+
In the preceding example, replace the values in angle brackets (`< >`) with your own bootstrap server and client credential information.
ifdef::qs[]
+
The values are described as follows:
+
--
* *bootstrap_server*: The bootstrap server endpoint for your Kafka instance. To access this information for a Kafka instance in {product-kafka}, select the options menu (three vertical dots). Click *Connection*.
* *client_id*: A client credential generated when you create a service account in {product-kafka}. You're prompted to copy and store this credential when you create the service account.
* *client_secret*: A client credential generated when you create a service account in {product-kafka}. You're prompted to copy and store this credential when you create the service account.
--
endif::[]
+
In this case, observe that the Node.js application uses the SASL/PLAIN authentication method (that is, the value of `KAFKA_SASL_MECHANISM` is set to `plain`). This means that the application uses only the client ID and client secret to authenticate with the Kafka instance. The application doesn't require an authentication token.

. Save the `rhoas.env` file.

ifdef::qs[]
.Verification
* Did you set environment variables for the Kafka instance?
endif::[]

[id="proc-creating-countries-topic_{context}"]
== Creating a Kafka topic in {product-kafka}

[role="_abstract"]
The Node.js application in this quick start uses a Kafka topic called `countries` to produce and consume messages. In this task, you'll create the topic in your Kafka instance.

.Prerequisites
* You've created a Kafka instance in {product-kafka} and the instance is in the *Ready* state.

.Procedure
. In the {product-kafka} web console, go to *Streams for Apache Kafka* > *Kafka Instances* and click the name of the Kafka instance that you want to add a topic to.
. Click *Create topic* and follow the guided steps to define the topic details. Click *Next* to complete each step and click *Finish* to complete the setup.
+
[.screencapture]
.Guided steps to define topic details
image::sak-create-countries-topic.png[Image of wizard to create a topic]

* *Topic name*: Enter `countries` as the topic name.
* *Partitions*: Set the number of partitions for this topic. This example sets the partition to `1` for a single partition. Partitions are distinct lists of messages within a topic and enable parts of a topic to be distributed over multiple brokers in the cluster. A topic can contain one or more partitions, enabling producer and consumer loads to be scaled.
* *Message retention*: Set the message retention time and size to the relevant value and increment. This example sets the retention time to `7 days` and the retention size to `Unlimited`. Message retention time is the amount of time that messages are retained in a topic before they are deleted or compacted, depending on the cleanup policy. Retention size is the maximum total size of all log segments in a partition before they are deleted or compacted.
* *Replicas*: For this release of {product-kafka}, the replicas are preconfigured. The number of partition replicas for the topic is set to `3` and the minimum number of follower replicas that must be in sync with a partition leader is set to `2`. Replicas are copies of partitions in a topic. Partition replicas are distributed over multiple brokers in the cluster to ensure topic availability if a broker fails. When a follower replica is in sync with a partition leader, the follower replica can become the new partition leader if needed.
+
After you complete the topic setup, the new Kafka topic is listed in the topics table for your Kafka instance. You can now run the Node.js application to start producing and consuming messages.

.Verification
ifdef::qs[]
* Is the `countries` topic listed in the topics table?
endif::[]
ifndef::qs[]
* Verify that the `countries` topic is listed in the topics table.
endif::[]

[id="proc-running-nodejs-example-application_{context}"]
== Running the Node.js example application

[role="_abstract"]
After you configure your Node.js application to connect to a Kafka instance, and you create the required Kafka topic, you're ready to run the application.

In this task, you'll run the following components of the Node.js application:

* A `producer-backend` component that generates random country names and sends these names to the Kafka topic.
* A `consumer-backend` component that consumes the country names from the Kafka topic.

.Prerequisites
* You've configured the Node.js example application to connect to a Kafka instance.
* You've created the `countries` Kafka topic.

.Procedure
. On the command line, navigate to the `reactive-example` directory of the repository that you cloned.
+
.Navigating to the reactive-example directory
[source]
----
$ cd reactive-example
----

. Navigate to the directory for the consumer component. Use Node Package Manager (npm) to install the dependencies for this component.
+
.Installing dependencies for the consumer component
[source]
----
$ cd consumer-backend
$ npm install
----

. Run the consumer component.
+
.Running the consumer component
[source]
----
$ node consumer.js
----
+
You should see the Node.js application run and connect to the Kafka instance. However, because you haven't yet run the producer component, the consumer has no country names to display.
+
If the application fails to run, review the error log in the command-line window and address any problems. Also, review the steps in this quick start to ensure that the application and Kafka topic are configured correctly.

. Open a second command-line window or tab.

. On the second command line, navigate to the `reactive-example` directory of the repository that you cloned.
+
.Navigating to the reactive-example directory
[source]
----
$ cd reactive-example
----

. Navigate to the directory for the producer component. Use Node Package Manager to install the dependencies for this component.
+
.Installing dependencies for the producer component
[source]
----
$ cd producer-backend
$ npm install
----

. Run the producer component.
+
.Running the producer component
[source]
----
$ node producer.js
----
+
You should see output like that shown in the example.
+
.Example output from the producer component
[source]
----
$ node producer.js
Ghana
Réunion
Guatemala
Luxembourg
Mayotte
Syria
United Kingdom
Bolivia
Haiti
----
+
As shown in the example, the producer component runs and generates messages that represent country names.

. Switch back to the first command-line window.
+
You should now see that the consumer component displays the same country names generated by the producer, and in the same order, as shown in the example.
+
.Example output from the consumer component
[source]
----
$ node consumer.js
Ghana
Réunion
Guatemala
Luxembourg
Mayotte
Syria
United Kingdom
Bolivia
Haiti
----
+
The output from both components confirms that they successfully connected to the Kafka instance. The components are using the Kafka topic that you created to produce and consume messages.
+
NOTE: You can also use the {product-long-kafka} web console to browse messages in the Kafka topic. For more information, see {base-url}{message-browsing-url-kafka}[_Browsing messages in the {product-long-kafka} web console_^].

. In your IDE, in the `producer-backend` directory of the repository that you cloned, open the `producer.js` file.
+
Observe that the producer component is configured to process environment variables from the `rhoas.env` file that you created. The component used the bootstrap server endpoint and client credentials stored in this file to connect to the Kafka instance.

. In the `consumer-backend` directory, open the `consumer.js` file.
+
Observe that the consumer component is also configured to process environment variables from the `rhoas.env` file that you created.

ifdef::qs[]
.Verification
* Did the producer component run and start generating random country names?
* Did the consumer component run and display the same country names generated by the producer, and in the same order?
endif::[]

ifdef::qs[]
[#conclusion]
====
Congratulations! You successfully completed the {product-kafka} Node.js quick start. You're now ready to use your own Node.js applications with {product-kafka}.
====
endif::[]

ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]
