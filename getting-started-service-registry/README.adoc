[id="chap-getting-started-service-registry"]
= Getting Started with {product-long}
ifdef::context[:parent-context: {context}]
:context: getting-started-service-registry

////
START GENERATED ATTRIBUTES
WARNING: This content is generated by running npm --prefix .build run generate:attributes
////


:community:
:imagesdir: ./images
:product-version: 1
:product-long: Application Services
:product: App Services
// Placeholder URL, when we get a HOST UI for the service we can put it here properly
:service-url: https://console.redhat.com/beta/application-services/streams/
:property-file-name: app-services.properties
:rhoas-version: 0.29.0

// Other upstream project names
:samples-git-repo: https://github.com/redhat-developer/app-services-guides

//URL components for cross refs
:base-url: https://github.com/redhat-developer/app-services-guides/blob/main/
:base-url-cli: https://github.com/redhat-developer/app-services-cli/tree/main/docs/
:getting-started-url: getting-started/README.adoc
:kafka-bin-scripts-url: kafka-bin-scripts/README.adoc
:kafkacat-url: kafkacat/README.adoc
:quarkus-url: quarkus/README.adoc
:rhoas-cli-url: rhoas-cli/README.adoc
:rhoas-cli-ref-url: commands
:topic-config-url: topic-configuration/README.adoc
:consumer-config-url: consumer-configuration/README.adoc
:service-binding-url: service-discovery/README.adoc

////
END GENERATED ATTRIBUTES
////

[IMPORTANT]
====
{product-long} is currently available for Development Preview. Development Preview releases provide early access to a limited set of features that might not be fully tested and that might change in the final GA version. Users should not use Development Preview software in production or for business-critical workloads. Limited documentation is available for Development Preview releases and is typically focused on fundamental user goals.
====

// Purpose statement for the assembly
[role="_abstract"]
As a developer of applications and services, you can use {product-long} to create and set up Service Registry instances and connect your applications and services to these instances. {product} is a managed cloud service that enables you to manage schema and API definitions in your applications without having to install, configure, run, and maintain your own Service Registry clusters.

//For more overview information about {product}, see [variablized link to overview here https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/].

ifndef::community[]
.Prerequisites
* You have a Red Hat account.
//* You have a subscription to {product-long}. For more information about signing up, see *<@SME: Where to link?>*.
endif::[]

// Condition out QS-only content so that it doesn't appear in docs.
// All QS anchor IDs must be in this alternate anchor ID format `[#anchor-id]` because the ascii splitter relies on the other format `[id="anchor-id"]` to generate module files.
ifdef::qs[]
[#description]
Learn how to create and set up your first Service Registry instance in {product-long}.

[#introduction]
Welcome to the {product-long} Getting Started quick start. In this quick start, you'll learn how to create and inspect a Service Registry instance, create a service account to connect an application or service to the instance, and create a schema in the instance.
endif::[]

[id="proc-creating-service-registry-instance_{context}"]
== Creating a Service Registry instance in {product}

Use the {product} web console to create and configure a Service Registry instance for your applications or services. An instance in {product} is an isolated virtual tenant in a multi-tenanted deployment with its own unique instance URL, and the configurations needed to connect to producer and consumer services.

ifndef::qs[]
.Prerequisites
* You're logged in to the {product} web console at {service-url}[^].
endif::[]

.Procedure
. In the {product} web console, go to *Service Registry* > *Service Registry Instances* and click *Create Service Registry instance*.
. Enter a unique *Instance name*, such as `my-service-registry-instance`. Optionally, you can also add a longer text describing for this instance.
. Click *Create* to start the creation process for your Service Registry instance.
--
[.screencapture]
.Service Registry instance configuration details
image::configure-service-registry-instance.png[Image of instance configuration details in Create Service Registry instance window]

The new Service Registry instance is listed in the instances table. When the instance *Status* is *Ready*, you can start using the Service Registry instance. You can use the options icon (three vertical dots) to view, connect to, or delete the instance as needed.

[.screencapture]
.Service Registry instance options menu
image::service-registry-instance-options.png[Image of Service Registry instance options menu]
--

.Verification
ifdef::qs[]
* Is the new Service Registry instance listed in the instances table?
* Is the state of the new Service Registry instance shown as *Ready*?
endif::[]
ifndef::qs[]
. Verify that the new Service Registry instance is listed in the instances table.
. Verify that the state of the new Service Registry instance is shown as *Ready*.
endif::[]


[id="proc-creating-service-account_{context}"]
== Creating a service account to connect to a Service Registry instance in {product}

To connect your applications or services to a Service Registry instance in the {product} web console, you need to create a service account, copy and save the generated credentials, and copy and save the instance URL. You'll use the service account information later when you configure your application.

.Prerequisites
* You've created a Service Registry instance and the instance is in *Ready* state.

.Procedure
. In the *Service Registry Instances* page of the web console, for the relevant Service Registry instance that you want to connect to, select the options icon (three vertical dots) and click *View connection information*.
. Depending on the client libraries you want to use, pick the API that suits your needs. *Core Registry API* is the most powerful and works with Apicurio client libraries. *Schema Registry compatibility API* provides compatibility with Confluent Schema Registry API, whereas *CNCF Schema Registry API* provides compatibility with CNCF specification.
. In the *Connection* page, copy the *Core Registry API* URL (or one of the other API URLs if you are going to use a different client) to a secure location. This is the server endpoint that you'll need for connecting to this Service Registry instance.
.  In the {product} web console left menu, go to *Streams for Apache Kafka* > *Service Accounts* and click *Create service account* to generate the credentials that you'll use to connect to a Service Registry instance.
+
NOTE: This is a temporary location for generating service accounts. In the next release, this location for generating service accounts and the granularity of the permissions will change.
. Copy the generated *Client ID* and *Client Secret* to a secure location.
+
IMPORTANT: The generated credentials are displayed only one time, so ensure that you've successfully and securely saved the copied credentials before closing the credentials window.

. After you save the generated credentials to a secure location, select the confirmation check box in the credentials window and close the window.
. For SASL/OAUTHBEARER authentication method, use `https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token` as the *Token endpoint URL* and store it to a secure location. This is the endpoint that you'll use with your service account credentials to authenticate the connection to this Service Registry instance.

+
NOTE: SASL/PLAIN authentication is also available for tools and libraries that don't support SASL/OAUTHBEARER, but SASL/OAUTHBEARER is recommended whenever possible. With SASL/PLAIN authentication, you use only the service account credentials to authenticate the connection to the Kafka instance.

+
Youâ€™ll use the service account information that you saved to configure your application to connect to your Service Registry instances when you're ready. For example, if you plan to use https://github.com/edenhill/kafkacat[Kafkacat^] to interact with your Kafka instance and deserialize Avro messages using {product}, you'll use this information to set your Schema Registry URL in the client environment variables.

.Verification
ifdef::qs[]
* Did you save the Service Registry instance URL to a secure location?
* Did you save the client credentials to a secure location?
endif::[]
ifndef::qs[]
. Verify that the Service Registry instance URL is saved to a secure location.
. Verify that the client credentials are saved to a secure location.
endif::[]

[id="proc-uploading-schema_{context}"]
== Uploading a schema to {product}

After you create a Service Registry instance, you can upload a schema and start serializing/deserializing messages with the schema.

.Prerequisites
* You've created a Service Registry instance and the instance is in *Ready* state.

.Procedure
. In the *Service Registry Instances* page of the web console, select the name of the Service Registry instance that you want to upload a schema to.
. Click *Upload Artifact* and fill up the form to define the schema details. Click *Upload* to complete the operation.
+
--
[.screencapture]
.Guided steps to define topic details
image::upload-schema.png[Image of form to upload a schema]

* *Group*: Enter a unique group name such as `my-org`, to organize and put this artifact into a named collection. Each group contains a logically related set of schemas or API designs, typically managed by a single entity, belonging to a particular application or organization.
+
NOTE:  Specifying a group is optional when using the Service Registry web console, where a `default` group is automatically created. When using the REST API or Maven plug-in, you can specify the `default` group in the API path if you do not want to create a unique group.
+
* *ID*: Set a unique for this group artifact ID such as `my-ID`. If you do not specify a unique artifact ID, Service Registry generates one automatically as a UUID.
* *Type*: Use the default Auto-Detect setting to automatically detect the artifact type, or select the artifact type from the drop-down, for example, Avro Schema or OpenAPI.
* *Artifact*: Artifact: Drag and drop or click Browse to upload a file. For this example copy and paste the following AVRO schema:
`{
"type": "record",
"namespace": "com.example",
"name": "FullName",
"fields": [
{ "name": "first", "type": "string" },
{ "name": "last", "type": "string" }
]}`.

After you complete the schema creation, the new artifact details are displayed.

* *Info*: Displays the artifact name, group, description, lifecycle status, when created, and last modified. Click the Edit Artifact Metadata pencil icon to edit the artifact name and description or add labels, and click Download to download the artifact file locally.
* *Content*: Displays a read-only view of the full artifact content.
* *Documentation*: (OpenAPI only): Displays automatically-generated REST API documentation.
* *Content Rules*: Also displays artifact Content Rules that you can enable and configure. You can configure a Validity Rule or Compatibility Rule, by selecting the appropriate rule configuration from the drop-down. For more details, see here (TODO add link).

You can now start serialazing and deserializing messages using this schema from Kafka applications.
--

. On the right side of the Artifact Details, click Upload new version to add a new artifact version.
. Use the trash next to Upload new version to delete the artifact.
+
IMPORTANT: Deleting an artifact deletes the artifact and all of its versions, and cannot be undone. Artifact versions are immutable and cannot be deleted individually.
.

.Verification
ifdef::qs[]
* Is the new schema in the Artifacts table?
endif::[]
ifndef::qs[]
* Verify that the new schema is listed in the Artifacts table.
endif::[]

[role="_additional-resources"]
== Additional resources
* https://kafka.apache.org/081/documentation.html#configuration[Configuration^] in Kafka
(TODO) add link the RHOSR docs

ifdef::qs[]
[#conclusion]
Congratulations! You successfully completed the {product} Getting Started quick start, and are now ready to use the service.
endif::[]

ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]
